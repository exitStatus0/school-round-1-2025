# Розширена лекція: **Основи мереж у Linux — просто й практично**

> Мета: дати чітке, просте й практичне розуміння мереж у Linux із прикладами команд і короткими вправами після кожного блоку. Пояснення «людяні», без перебільшених метафор, акцент на тому, **як подивитися й перевірити** у себе.

---

## Що ви навчитеся робити
- Читати свою IP-адресу, маршрути та DNS-конфігурацію.
- Розуміти порти, протоколи **TCP** та **UDP** й знаходити, **який процес слухає порт**.
- Користуватися **ping**, **traceroute/mtr**, **dig/nslookup**, **ss/lsof**.
- Розрізняти **loopback (127.0.0.1)** і зовнішні адреси.
- Безпечно перевіряти продуктивність ICMP (**ping flood лише локально**).
- Швидко діагностувати часті мережеві проблеми на Linux‑хості.

> **Позначення в коді**: символ `$` означає команду в терміналі, що виконується від звичайного користувача; `#` — від імені root або з `sudo`.

---

## 0) Швидкі домовленості
- Сучасні аналоги: `ip` (замість `ifconfig`), `ss` (замість `netstat`), `dig` (поряд із `nslookup`).
- Приклади виводу можуть трохи відрізнятися на вашій системі — це нормально.
- Коли ви бачите `sudo`, знадобляться права адміністратора.

---

## 1) IP‑адресація (IPv4) — як дізнатись «де ви»
**Ідея:** кожен мережевий інтерфейс має адресу. Найчастіше вам потрібні: IP, маска (CIDR) і дефолтний маршрут.

```bash
$ ip -br addr         # компактний огляд інтерфейсів і адрес
$ ip addr show eth0   # детально для конкретного інтерфейсу
$ ip route            # таблиця маршрутів; шукайте "default via ..."
```

Приклад фрагмента виводу:
```
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500
    inet 192.168.1.50/24 brd 192.168.1.255 scope global eth0
```
Тут IP — `192.168.1.50`, маска — `/24` (тобто 255.255.255.0).

**Міні‑вправа:**  
1) Виконайте `ip -br addr` і запишіть свою адресу IPv4.  
2) Виконайте `ip route | sed -n '1p'` — як виглядає ваш «default via …»?

---

## 2) Loopback (127.0.0.1) — «я сам»
**Ідея:** адреса 127.0.0.1 (або ім’я `localhost`) завжди вказує на **цей самий** комп’ютер. Зручно для розробки і тестів.

```bash
$ ping -c 3 127.0.0.1
$ curl -I http://127.0.0.1:80   # якщо у вас є локальний веб‑сервер
```

**Навіщо:** програми можуть взаємодіяти між собою «мережево», не виходячи в зовнішню мережу.

**Міні‑вправа:**  
Пінгніть `127.0.0.1` і перевірте, що отримуєте відповіді без втрат пакетів.

---

## 3) Порти та процеси — хто «слухає»?
**Ідея:** порт — «двері» застосунку. Діапазон 0–65535, окремо для **TCP** і **UDP**. На одному IP **не можуть** одночасно слухати **2 процеси** той самий **порт/протокол**.

Подивитись слухачів і з’єднання:
```bash
$ ss -ltnp         # TCP-слухачі + PID/процес
$ ss -punt         # UDP і TCP
$ sudo lsof -i -P -n   # сокети ↔ процеси (потрібні права)
```

Приклад: хто слухає 5432 (PostgreSQL)?
```bash
$ ss -ltnp | grep ':5432'
```

**Міні‑вправа:**  
1) Знайдіть, хто слухає TCP‑порт 22/80/443/5432 на вашій машині.  
2) Якщо порт зайнятий, спробуйте знайти PID і ім’я процесу через `lsof` і `ps`.

---

## 4) TCP vs UDP — у чому різниця?
- **TCP** — «надійно й послідовно»: встановлення з’єднання (3‑way handshake), контроль доставки та порядку пакетів, повторні передачі, виявлення втрат. Добре для веб‑сторінок/файлів/БД.
- **UDP** — «мінімальні накладні витрати»: без встановлення з’єднання, **без** гарантії доставки/порядку. Добре для стрімінгу/VoIP/ігор, де важлива швидкість і прийнятні часткові втрати.

Спробуйте швидкий локальний тест із `netcat`:
```bash
# В одному терміналі — TCP-сервер
$ nc -l -p 9999

# В іншому — TCP-клієнт
$ echo "hello over TCP" | nc 127.0.0.1 9999

# Для UDP (замість TCP): додайте -u
$ nc -u -l -p 9998            # сервер
$ echo "hello over UDP" | nc -u 127.0.0.1 9998  # клієнт
```

**Міні‑вправа:**  
1) Передайте фразу через TCP і UDP (як вище).  
2) Поясніть, чому для відеодзвінків часто обирають UDP.

---

## 5) DNS — домен → IP
**Ідея:** люди пам’ятають імена, машини — адреси. DNS перетворює домен (`example.com`) на IP (A/AAAA), є також записи CNAME, MX, TXT, NS.

Команди:
```bash
$ dig +short example.com A
$ dig +short example.com AAAA
$ dig +trace example.com         # весь ланцюжок запиту
$ nslookup example.com           # класична альтернатива
```

**Міні‑вправа:**  
Знайдіть A‑ та AAAA‑записи для 2–3 доменів. Спробуйте `dig +trace` і порахуйте, скільки «кроків» до авторитетної відповіді.

---

## 6) Перевірка зв’язності: ping
`ping` надсилає ICMP Echo Request і міряє **затримку (latency)** та **втрати**.

```bash
$ ping -c 4 8.8.8.8
$ ping -c 4 google.com     # виконує ще й DNS‑резолвінг
```

Фінальні «ping statistics» покажуть передані/отримані пакети, % втрат і RTT min/avg/max.

**Міні‑вправа:**  
Порівняйте затримку до `127.0.0.1`, вашого роутера (наприклад, 192.168.1.1) та публічної адреси (8.8.8.8).

---

## 7) Шлях до вузла: traceroute / mtr
`traceroute` збільшує TTL від 1 вгору, отримуючи відповіді «Time Exceeded» — так будується список проміжних вузлів (хопів).

```bash
$ traceroute 8.8.8.8
# або інтерактивний mtr (може знадобитись установка):
$ mtr -rw 8.8.8.8
```

Зірочки `*` означають, що вузол не відповів на пакети для цього TTL.

**Міні‑вправа:**  
Пройдіться трасою до `1.1.1.1` та `google.com`. На якому хопі росте затримка?

---

## 8) Ping flood — тільки для локальних тестів
**Ідея:** `ping -f` шле пакети максимально швидко. Це **лише для лабораторних тестів** і **лише** на своїх ресурсах (наприклад, `127.0.0.1`).

```bash
$ sudo ping -f -c 10000 127.0.0.1
```
Побачите статистику за великою кількістю пакетів. **Не** запускайте flood на чужі хости — це може бути розцінено як атака.

**Міні‑вправа:**  
Запустіть короткий flood на `127.0.0.1` і порівняйте статистику з «звичайним» `ping -c 10000 127.0.0.1`.

---

## 9) Маршрути, шлюз і «куди піде пакет»
`ip route` показує таблицю маршрутів; зазвичай є запис «default via …» — це ваш шлюз.

```bash
$ ip route
default via 192.168.1.1 dev eth0
192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.50
```

**Міні‑вправа:**  
Знайдіть свій дефолтний маршрут і поясніть, куди піде пакет до `8.8.8.8`: напряму чи через шлюз?

---

## 10) Firewall — що дозволено, а що ні
На Linux часто використовують `nftables`/`iptables` і обгортки типу `ufw`/`firewalld`.
- Хостовий фаєрвол контролює вхід/вихід на рівні вашого сервера.
- У хмарі додатково існують «security groups»/ACL на периметрі.

Приклади з `ufw` (Ubuntu):
```bash
$ sudo ufw status
$ sudo ufw allow 8080/tcp   # відкрити TCP-порт 8080
$ sudo ufw delete allow 8080/tcp
```

**Міні‑вправа:**  
Перевірте стан `ufw`. Якщо він увімкнений — додайте правило для тестового порту, перевірте `ss -ltnp`, потім видаліть правило.

---

## 11) Практичні міні‑сценарії (діагностика)
### Сценарій A: «Сайт не відкривається»
1. `ping -c 4 example.com` — є відповіді?
2. `dig +short example.com A` — резолвиться IP?
3. `traceroute example.com` — на якому хопі зависає?
4. Якщо сервіс ваш: `ss -ltnp | grep ':443\|:80'` — веб‑сервер слухає?

### Сценарій B: «Порт зайнятий»
```bash
$ ss -ltnp | grep ':8080'
$ sudo lsof -iTCP:8080 -sTCP:LISTEN -n -P
$ ps -fp <PID>
```
Знайдіть процес, звільніть порт або змініть конфіг сервісу.

### Сценарій C: «Є IP, але немає Інтернету»
- `ip route` — чи є «default via …»?
- `/etc/resolv.conf` — чи є DNS‑сервери?
- Фаєрвол/хмарні правила — не блокують вихід?

---

## 12) Контрольні питання
1. Чому дві програми не можуть слухати один і той самий порт/протокол на одному IP?
2. Чим TCP відрізняється від UDP і де який краще застосовувати?
3. Для чого потрібен loopback і чим він відрізняється від зовнішніх адрес?
4. Яку інформацію дають «ping statistics»?
5. Як `traceroute` дізнається список хопів?
6. Де подивитись, хто слухає порт 5432?
7. Що показує `ip route` і як знайти дефолтний шлюз?
8. Як дізнатися IP домену та пройти увесь ланцюг резолвінгу?

---

## 13) Часті помилки й як їх виправити
- **DNS не налаштований** → є IP, але домени не резолвляться. Перевірте `/etc/resolv.conf` або NetworkManager.
- **Немає дефолтного маршруту** → лише локальна мережа доступна. Додайте `default via …` (через DHCP/NetworkManager/`ip route add`).
- **Порт зайнятий іншим процесом** → знайдіть PID через `ss`/`lsof`.
- **Фаєрвол блокує** → перевірте `nft/iptables` або `ufw`/`firewalld`, плюс хмарні SG/ACL.
- **Плутаєте TCP/UDP** → сервіс слухає TCP, а ви перевіряєте UDP (або навпаки).

---

## 14) Шпаргалка (команди)
```bash
# IP/інтерфейси/маршрути
ip -br addr
ip route
ping -c4 1.1.1.1

# DNS
dig +short example.com A
dig +short example.com AAAA
dig +trace example.com
nslookup example.com

# Порти/процеси
ss -ltnp
ss -punt
sudo lsof -i -P -n
sudo lsof -iTCP:80 -sTCP:LISTEN -n -P

# Траса
traceroute 8.8.8.8
mtr -rw 8.8.8.8

# Лабораторні
nc -l -p 9999
echo "hello" | nc 127.0.0.1 9999
nc -u -l -p 9998
echo "hello" | nc -u 127.0.0.1 9998

# Безпечно про flood — лише локально
sudo ping -f -c 10000 127.0.0.1
```

---

### Висновок
Опанувавши IP, порти, TCP/UDP, DNS і базові інструменти (`ip`, `ss`, `dig`, `ping`, `traceroute/mtr`), ви вже можете впевнено діагностувати більшість мережевих проблем на Linux‑сервері і у себе локально.
