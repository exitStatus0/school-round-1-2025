# Лекція: **Просунуті концепції Bash‑скриптингу: змінні, умови, параметри, `read`, цикли**

> У цій лекції поглиблюємося в **Bash**: змінні та підстановка команд, умовні конструкції `if/elif/else`, параметри скрипта й читання вводу користувача, цикли `for` та `while`, арифметика `(( ))`, а також безпечні патерни написання скриптів.

---

## Навчальні цілі
Після лекції ви зможете:
- Коректно оголошувати, читати й передавати **змінні**, включно з підстановкою команд `$(...)`.
- Писати **умови** з перевірками файлів, числовими та рядковими порівняннями.
- Приймати **параметри** (`$1`, `$@`, `$#`) і взаємодіяти з користувачем через **`read`** (у т.ч. прихований ввід).
- Використовувати **цикли** `for`/`while` для автоматизації масових операцій.
- Застосовувати **арифметику** `(( ))` та `$(())`.
- Знати, коли доречно використовувати **`[[ ... ]]`** і чим воно відрізняється від `[ ... ]`.
- Уникати поширених помилок (`"$@"` vs `"$*"`, цитування та глобінг, коди виходу).

---

## План лекції
1. Змінні та підстановка команд
2. Умови `if/elif/else`: файли, числа, рядки
3. Параметри скрипта: `$1`, `$@`, `$#`, значення за замовчуванням
4. Інтерактивне введення: `read` (+ прихований ввід `-s`)
5. Цикли `for` і `while`
6. Арифметика `(( ))`
7. `[[ ... ]]` проти `[ ... ]`
8. Практикум (20–30 хв)
9. Поширені помилки та поради
10. Контрольні питання
11. Аналогія «Диригент і оркестр»
12. Шпаргалка

---

## 1) Змінні та підстановка команд

Оголошення і використання:
```bash
config_file="config.yml"
echo "Використовуємо файл: $config_file"
```

Підстановка команд (`$(...)`) і арифметична підстановка:
```bash
now_iso="$(date -Is)"
files_count="$(ls -1 config 2>/dev/null | wc -l)"
sum=$(( 40 + 2 ))     # → 42
echo "at=$now_iso, count=$files_count, sum=$sum"
```

> Імена змінних зручно писати як `snake_case` (`file_name`) або `camelCase` (`fileName`).  
> **Завжди цитуйте** змінні при виводі/передачі у команди: `"$var"` — це захищає від пробілів і спецсимволів.

---

## 2) Умови `if/elif/else`: файли, числа, рядки

Базовий синтаксис:
```bash
if [ умова ]; then
  # дії
elif [ інша_умова ]; then
  # дії
else
  # запасний варіант
fi
```

Перевірки **файлів/каталогів**:
```bash
if [ -d "/etc" ]; then echo "/etc — каталог"; fi
if [ -f "$config_file" ]; then echo "Є файл $config_file"; fi
if [ -r "$config_file" ] && [ -s "$config_file" ]; then echo "Читається і не порожній"; fi
```

**Числові** порівняння: `-eq`, `-ne`, `-lt`, `-gt`, `-le`, `-ge`
```bash
if [ "$files_count" -gt 0 ]; then echo "Є файли"; else echo "Порожньо"; fi
```

**Рядкові** порівняння:
```bash
if [ "$MODE" = "prod" ]; then echo "Режим prod"; fi
if [ "$A" != "$B" ]; then echo "Рядки різні"; fi
[ -z "$s" ] && echo "Порожній рядок" || echo "Непорожній"
```

---

## 3) Параметри скрипта: `$1`, `$@`, `$#`

Виклик: `./setup.sh MyDir admin` → `$1="MyDir"`, `$2="admin"`

Усередині скрипта:
```bash
target_dir="${1:-/opt/app}"   # значення за замовчуванням
user_group="${2:-appgrp}"
echo "dir=$target_dir, group=$user_group"
echo "кількість параметрів: $#"
```

Різниця **`$@` vs `$*`**:
- **`"$@"`** — список **окремих** аргументів (вірно для циклів).
- **`"$*"`** — усі аргументи **одним рядком** (рідко потрібно).

```bash
# Правильно і безпечно:
for arg in "$@"; do
  echo "arg=$arg"
done
```

---

## 4) Інтерактивне введення: `read`

З підказкою:
```bash
read -rp "Введіть ім'я каталогу: " target_dir
```

Прихований ввід (наприклад, пароль):
```bash
read -rsp "Введіть пароль: " user_password
echo    # перенесення рядка після прихованого вводу
```

Читання рядків із файлу/pipe (робота з пробілами й бекслешами):
```bash
while IFS= read -r line; do
  printf 'line: %s\n' "$line"
done < input.txt
```

---

## 5) Цикли `for` і `while`

**for** по параметрах або файлах:
```bash
for p in "$@"; do
  echo "param=$p"
done

for f in *.log; do
  [ -e "$f" ] || continue   # пропустити, якщо шаблон не збігся
  gzip -9 -- "$f"
done
```

**while** із умовою/нескінченний цикл:
```bash
count=0
while [ "$count" -lt 3 ]; do
  echo "count=$count"
  count=$((count+1))
done

# спостереження за станом із паузою
while ! systemctl is-active --quiet nginx; do
  echo "Чекаємо старт nginx..."; sleep 1
done
echo "nginx активний"
```

`break` — негайний вихід із циклу; `continue` — перехід до наступної ітерації.

---

## 6) Арифметика `(( ))`

Арифметичні операції та інкремент/декремент:
```bash
sum=0
score=7
sum=$(( sum + score ))
(( sum++ ))
(( sum >= 10 )) && echo "Достатньо" || echo "Ще ні"
```

---

## 7) `[[ ... ]]` проти `[ ... ]`

- `[[ ... ]]` — розширений синтаксис Bash (не POSIX). Зручний для **шаблонів** і безпечніший щодо деяких випадків розширення.
- Патерни в `[[ ... ]]`:
```bash
if [[ "$fname" == *.yml ]]; then echo "YAML"; fi
if [[ "$text" == *"error"* ]]; then echo "Знайдено слово 'error'"; fi
```
- У більшості випадків **продовжуйте цитувати змінні**: це гарна звичка й уникнення сюрпризів.
- Для максимальної портативності (POSIX‑скрипти) використовуйте `[ ... ]`.

---

## 8) Практикум (20–30 хв)

1) **Фільтр логів за рівнем**
```bash
#!/usr/bin/env bash
set -euo pipefail

level="${1:-ERROR}"
read -rp "Шлях до логу: " log
[ -f "$log" ] || { echo "Нема файлу: $log" >&2; exit 1; }
grep -i "$level" -- "$log" | wc -l
```

2) **Бекап каталогів, переданих параметрами**
```bash
#!/usr/bin/env bash
set -euo pipefail

dest="${1:-/tmp/backup}"; shift || true
mkdir -p "$dest"
for dir in "$@"; do
  [ -d "$dir" ] || { echo "Пропуск: $dir — не каталог"; continue; }
  base="$(basename "$dir")"
  tar -czf "$dest/${base}-$(date +%F).tgz" -C "$(dirname "$dir")" "$base"
done
```

3) **Перевірка конфігів**
```bash
#!/usr/bin/env bash
set -euo pipefail

for f in /etc/*.conf; do
  [ -s "$f" ] && echo "OK: $f" || echo "WARN: $f порожній"
done
```

---

## 9) Поширені помилки та поради

- **`"$@"` vs `"$*"`**: для перебору аргументів використовуйте **`"$@"`**.
- Відсутнє **цитування** змінних → ламання на пробілах/символах.
- Змішування `sh`/`bash`: конструкції `[[ ]]`, `(( ))`, `==` — специфічні для Bash.
- Неопрацьовані помилки: увімкніть **`set -euo pipefail`**, додавайте перевірки `|| exit 1`.
- Неправильні тести: `-f` (файл), `-d` (каталог), `-x` (виконуваний), `-s` (непорожній).
- Читання файлів циклом: використовуйте `IFS= read -r` замість `for line in $(cat ...)`.
- Локаль/сорсинг: для чисел використовуйте арифметику `(( ))`, не зовнішній `expr`.

---

## 10) Контрольні питання

1. Як задати **значення за замовчуванням** для `$1`?
2. Чим відрізняються `"$@"` і `"$*"`?
3. Які є **перевірки файлів** і коли вони корисні?
4. Як приховано зчитати пароль користувача?
5. Наведіть приклад циклу **while**, що чекає на стан сервісу.
6. Для чого використовують `[[ ... ]]` і у чому різниця з `[ ... ]`?

---

## 11) Аналогія: «Диригент і оркестр»

- **Змінні** — нотні партії для інструментів: напишіть один раз — використовуйте багато разів.
- **if/elif/else** — жести диригента: хто грає за яких умов.
- **Параметри** — побажання перед концертом: «сьогодні швидше/повільніше».
- **`read`** — репетиція з питаннями до музикантів (інтерактивність).
- **for/while** — повтор секцій твору або прогін усіх інструментів.
- **Арифметика** — розрахунок темпу і такту.
- **`[[ ]]`** — розширений інструмент перевірок і «нюансів» у партитурі.

---

## 12) Шпаргалка

```bash
# Змінні й підстановка
VAR="value"; echo "$VAR"
NOW="$(date -Is)"; N=$((N+1))

# Умови
[ -f file ] && echo "файл" || echo "ні"
if [[ "$s" == *pattern* ]]; then ...; fi

# Параметри
echo "argc=$#"; for a in "$@"; do echo "$a"; done
name="${1:-world}"

# read
read -rp "Введіть значення: " val
read -rsp "Пароль: " pass; echo

# Цикли
for f in *.log; do [ -e "$f" ] || continue; done
while ! ping -c1 host >/dev/null 2>&1; do sleep 1; done

# Арифметика
(( i=0, i<5, i++ )) || true

# Безпека
set -euo pipefail
```

---

> **Висновок:** Ці прийоми перетворюють Bash‑скрипти на надійний інструмент автоматизації. Починайте з малих сценаріїв, дотримуйтеся безпечних практик (цитування, `set -euo pipefail`), і поступово нарощуйте складність — коли потрібно, доповнюйте Bash мовами на кшталт **Python** або інструментами конфігурації (**Ansible**).
