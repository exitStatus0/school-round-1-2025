# Лекція: **Файлова система Linux — структура, каталоги та порівняння з Windows**

> У цій лекції розбираємо ієрархію файлової системи Linux, призначення ключових каталогів, відмінності від Windows і практичні прийоми навігації та налагодження.

---

## Навчальні цілі
Після лекції ви зможете:
- Пояснити деревоподібну ієрархію Linux з **єдиним коренем `/`** та відмінності від дискової моделі Windows (**`C:\`**, **`D:\`**).
- Орієнтуватися у **ключових системних каталогах**: `/bin`, `/sbin`, `/lib`, `/usr`, `/usr/local`, `/opt`, `/etc`, `/var`, `/dev`, `/boot`, `/tmp`, `/media`, `/mnt`.
- Розуміти призначення **домашніх каталогів** і **прихованих файлів** (dotfiles).
- Знати, куди встановлюються **системні програми** та як пакетні менеджери розкладають файли.
- Застосовувати базові команди для дослідження файлової системи та усунення проблем.

---

## План лекції
1. Огляд: структура файлової системи Linux vs Windows
2. Домашній каталог користувача (`/home`)
3. Системні двійкові файли та бібліотеки: `/bin`, `/sbin`, `/lib`
4. Каталог `/usr` і його підкаталоги
5. Де живуть системні інсталяції: `/usr/local` та `/opt`
6. Інші важливі каталоги: `/boot`, `/etc`, `/dev`, `/var`, `/tmp`, `/media`, `/mnt`
7. Взаємодія з файловою системою та роль пакетних менеджерів
8. Приховані файли (dotfiles)
9. Аналогія «велика бібліотека»
10. Практикум (15–25 хв), поширені помилки, контрольні питання, глосарій

---

## 1) Структура файлової системи Linux

**Linux** має **ієрархічну деревоподібну структуру** з **єдиною кореневою текою `/`**, від якої походять усі інші каталоги та файли.

**Windows** використовує **кілька коренів**, представлених літерами дисків (**`C:\`**, **`D:\`** тощо) — історично це пов’язано з епохою знімних носіїв.

| Платформа | Корінь | Приклад шляху |
|---|---|---|
| Linux | `/` | `/home/exitStatus0/Documents/report.txt` |
| Windows | `C:\`, `D:\` | `C:\Users\exitStatus0\Documents\report.txt` |

> **Висновок:** в Linux **усе — під `/`**, незалежно від фізичних або логічних розділів: вони просто «підмонтовуються» у певні точки дерева.

---

## 2) Домашній каталог (Home Directory)

- Кожен користувач має власну теку в **`/home`**: наприклад, **`/home/exitStatus0`**.
- Це забезпечує **ізоляцію користувачів** у багатокористувацьких системах (налаштування, програми, особисті файли).
- **Користувач `root`** має окремий **домашній каталог `/root`** (не в `/home`).  
- Типові підтеки: `Desktop`, `Documents`, `Downloads`, `Pictures`, `Videos`, `Projects` тощо.

> **Порада:** зручно використовувати змінну середовища **`$HOME`** або команду `cd ~`.

```bash
whoami
echo $HOME
cd ~
pwd
ls -la
```

---

## 3) Системні двійкові файли та бібліотеки

### `/bin` — **Binary**
Базові системні команди, доступні всім користувачам та самій системі.  
Приклади: `cat`, `cp`, `mv`, `echo`, `ls`, `mkdir`, `rm`.

### `/sbin` — **System Binary**
Критично важливі команди для адміністрування; часто вимагають привілеїв суперкористувача.  
Приклади: `adduser`, `passwd`, `iptables` (або сучасні `nft`/`ip`), `shutdown`.

### `/lib` — **Library**
Динамічні бібліотеки, від яких залежать виконувані файли з `/bin`, `/sbin` тощо.  
Компоненти однієї програми можуть бути розділені: двійковий файл у `/bin`/`/sbin`, а бібліотеки — у `/lib`.

> **Примітка:** У сучасних дистрибутивах часто використовується уніфікація, де `/bin` і `/sbin` є посиланнями на відповідники в `/usr` (див. нижче).

---

## 4) Каталог `/usr`

Історично `/usr` означав **user**, і в ньому розміщувалися користувацькі дані до появи `/home`. Сьогодні це велике дерево **системних** файлів «користувацького простору»: програми, бібліотеки, документація.

Поширені підкаталоги:
- **`/usr/bin`** — більшість користувацьких команд (наприклад, `ls`, `cp`, `grep`, `python`, `node`).
- **`/usr/sbin`** — системні команди для адміністрування.
- **`/usr/lib`** — бібліотеки для програм із `/usr/bin` і `/usr/sbin`.
- **`/usr/share`** — архітектурно-незалежні дані (документація, локалі, мануали, іконки тощо).
- **`/usr/include`** — заголовки для компіляції (C/C++).

> Історично дублювання `/bin` vs `/usr/bin`, `/sbin` vs `/usr/sbin` виникло через обмеження дискового простору; сьогодні команди часто фізично живуть у `/usr/bin` тощо.

---

## 5) Системні встановлення програм: `/usr/local` та `/opt`

- **`/usr/local`** — місце для **сторонніх програм**, встановлених **системно** адміністратором (Docker, Java, Python, Git).  
  Поширені шляхи:  
  - `/usr/local/bin` — двійкові файли,
  - `/usr/local/lib` — бібліотеки,
  - `/usr/local/share` — спільні дані/документація.
  Такі програми зазвичай доступні **всім користувачам**.

- **`/opt`** — для **самодостатніх** застосунків, які не розкладаються по множинних каталогах, а встановлюються **єдиним деревом** (IDE, браузери, інструменти з власним апдейтером).  
  Приклад структури: `/opt/SomeApp/bin`, `/opt/SomeApp/lib`, `/opt/SomeApp/resources`.

- **Локальні (per-user) інсталяції** зазвичай розміщуються всередині **домашнього каталогу** користувача (наприклад, `~/.local/bin`).

---

## 6) Інші важливі каталоги

- **`/boot`** — файли для завантаження системи (ядро, initramfs, завантажувач). **Не змінюйте**, якщо не розумієте наслідків.
- **`/etc`** — конфігураційні файли системи та сервісів: мережа, користувачі, паролі, конфіги `nginx`, `MySQL`, `ssh` тощо. Зазвичай **текстові** і **редаговані**.
- **`/dev`** — файлові інтерфейси до пристроїв (диски, tty, USB, аудіо/відео). ОС взаємодіє з «залізом» через ці **device files**.
- **`/var`** — змінні дані: журнали (**`/var/log`**), кеші (**`/var/cache`**), спули (**`/var/spool`**), БД деяких сервісів.
- **`/tmp`** — тимчасові файли програм. Зазвичай очищається автоматично.
- **`/media`** — **автоматичне** монтування зовнішніх носіїв (USB, зовнішні HDD, мережеві шари).
- **`/mnt`** — **ручне** монтування файлових систем (адміністратор для тимчасових/разових задач).

> **Порада:** додатково корисні `/proc` (віртуальна FS з інформацією про процеси/ядро) і `/run` (стан системних сервісів після завантаження).

---

## 7) Взаємодія з файловою системою

Більшість системних папок **не потребують прямої взаємодії** користувача. Керування файлами програм зазвичай виконують **пакетні менеджери** або інсталятори, які:
- розкладають файли у правильні місця,
- відстежують їх для **оновлень** та **видалення**,
- узгоджують **залежності**.

```bash
# Debian/Ubuntu
apt show curl
apt install curl
dpkg -L curl           # де саме розкладено файли пакета

# RHEL/CentOS/Fedora
dnf info curl
dnf install curl
rpm -ql curl
```

---

## 8) Приховані файли (dotfiles)

- **Приховані файли/теки** починаються з крапки: **`.name`** (наприклад, `~/.bashrc`, `~/.config`, `~/.mozilla`).  
- Використовуються для **конфігурацій**, **скриптів**, **кешів**, налаштувань профілю тощо.
- Створюються автоматично програмами або вручну користувачем.
- Аналогічна концепція існує в Windows/macOS, але в Linux це **стандарт де-факто** для користувацьких конфігів.

```bash
ls -A ~          # показати всі (включно з прихованими)
grep -n "alias" ~/.bashrc
mkdir -p ~/.config/mytool
```

---

## 9) Аналогія: «Велика бібліотека»

- **`/`** — **вхід** до всієї бібліотеки.
- Кожен каталог — **окремий відділ/полиця** з чітким призначенням:  
  - `/home` — «читальні зали» для кожного користувача,  
  - `/bin` — «універсальні інструкції» доступні всім,  
  - `/etc` — «адміністративні правила та налаштування».
- **Приховані файли** — «службові картки/нотатки бібліотекаря», які не заважають відвідувачам.

---

## 10) Практикум (15–25 хв)

> **Мета:** навчитися швидко орієнтуватися у файловій системі, знаходити двійкові файли, конфіги та журнали.

1. **Навігація та огляд**
   ```bash
   pwd
   tree -L 1 /           # якщо немає tree: sudo apt install tree
   ls -l /bin | head
   ls -l /usr/bin | head
   ls -l /sbin | head
   ```

2. **Пошук команд і бібліотек**
   ```bash
   which ls
   whereis ls
   ldd "$(which ls)"     # показати залежності бібліотек виконуваного файлу
   ```

3. **Конфігурації та журнали**
   ```bash
   ls -l /etc | head
   sudo ls -l /var/log | head
   sudo tail -n 100 /var/log/syslog  # на RHEL/centos: /var/log/messages
   ```

4. **Пристрої, монтування, тимчасові файли**
   ```bash
   ls -l /dev | head
   lsblk
   mount | head
   df -h
   ls -l /tmp | head
   ```

5. **Домашній каталог і dotfiles**
   ```bash
   cd ~
   ls -A | head
   grep -n "PATH" ~/.profile ~/.bashrc 2>/dev/null
   ```

> *Результат:* ви швидко орієнтуєтесь у ключових місцях FS Linux і знаєте, де шукати програми, конфіги, бібліотеки та журнали.

---

## Поширені помилки та поради

- **Редагування `/boot` або системних конфігів без розуміння наслідків** — може зробити систему незавантажуваною. Робіть **бекап**.
- **Плутанина між `/bin` і `/usr/bin`** — у сучасних системах це часто одна й та сама місцевість через уніфікацію. Дивіться `which`, `readlink -f`.
- **Змішування системних і локальних інсталяцій** — домовтесь про політику: **`/usr/local`** для кастомних системних інсталяцій, **`/opt`** для монолітних застосунків, **`~/.local`** для користувача.
- **Ігнорування логів** — проблеми часто «говорять» у **`/var/log`**; використовуйте `journalctl` на системах з systemd.

---

## Контрольні питання

1. Чому в Linux є **єдина коренева тека `/`**, а у Windows — кілька коренів дисків?
2. Чим відрізняються **`/bin`** і **`/sbin`**?
3. Для чого існують **`/usr/local`** та **`/opt`** і чим вони різняться?
4. Де шукати **конфіги** сервісів і де — **журнали**?
5. Що таке **dotfiles** і як їх переглянути?

---

## Глосарій

- **Корінь (`/`)** — верхівка дерева файлової системи Linux.
- **Домашній каталог** — особистий простір користувача: `/home/<name>`; для `root` — `/root`.
- **Двійковий файл (binary)** — виконуваний файл програми.
- **Бібліотека (library)** — спільні компоненти, якими користуються програми.
- **Пакетний менеджер** — інструмент встановлення/оновлення/видалення ПЗ (apt, dnf, pacman тощо).
- **Монтування (mount)** — приєднання файлової системи/пристрою у дерево каталогів.
- **Dotfiles** — приховані файли/теки, що починаються з крапки (.).

---

> **Короткий підсумок:** Файлова система Linux — це логічне дерево з єдиним коренем. Розуміння призначення ключових каталогів допомагає швидше встановлювати програми, шукати конфіги, читати журнали й ефективно усувати проблеми.
