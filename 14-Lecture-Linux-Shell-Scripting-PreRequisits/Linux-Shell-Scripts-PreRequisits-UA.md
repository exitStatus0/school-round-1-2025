# Лекція: **Конвеєризація (piping) та перенаправлення (redirection) у Linux**

> У цій лекції розберемо, як з’єднувати команди **конвеєрами** (`|`) і як **перенаправляти** потоки вводу/виводу (`>`, `>>`, `2>`, `2>&1`). Це базові прийоми для ефективної роботи в терміналі, аналізу логів і автоматизації.

---

## Навчальні цілі
Після лекції ви зможете:
- Пояснити різницю між **stdin**, **stdout**, **stderr**.
- Будувати **конвеєри** з кількох команд (`cmd1 | cmd2 | cmd3`).
- Використовувати **перенаправлення** у файл: `>`, `>>`, `2>`, `2>>`, `2>&1`, `&>`.
- Поєднувати фільтрацію (`grep`, `less`, `sort`, `uniq`, `wc`) з конвеєрами.
- Виконувати **кілька команд** в одному рядку (`;`, `&&`, `||`).
- Застосовувати практичні шаблони для аналізу логів і дебагу.
  
---

## План лекції
1. Конвеєризація: `|` — передати stdout наступній команді
2. Перенаправлення: `>`, `>>` — запис у файл
3. Стандартні потоки: **stdin/stdout/stderr** і їхнє керування
4. Кілька команд в одному рядку: `;`, `&&`, `||`
5. Практикум (15–25 хв)
6. Поширені помилки та поради
7. Контрольні питання
8. Аналогія «Фабрика та конвеєр»
9. Шпаргалка операторів

---

## 1) Конвеєризація (`|`) — з’єднання команд

Кожна команда має **вхід (stdin)** і **вихід (stdout)**. Оператор `|` передає **stdout** попередньої команди на **stdin** наступної.

### Приклади
**Перегляд великих обсягів посторінково (`less`):**
```bash
cat /var/log/syslog | less
ls /usr/bin | less
history | less
```
`less`: **Space** — далі, **B** — назад, **Q** — вихід, **/** — пошук, **N**/**n** — попередній/наступний збіг.

**Фільтрування рядків (`grep`):**
```bash
history | grep sudo
history | grep "sudo chmod"
ls /usr/bin | grep -i java
cat config.yml | grep port
```
Поєднання фільтрації та пагінації:
```bash
history | grep "sudo chmod" | less
```

**Типові корисні ланцюжки:**
```bash
# Топ найуживаніших команд з історії
history | awk '{print $2}' | sort | uniq -c | sort -nr | head

# Живий перегляд помилок у логах сервісу
journalctl -u nginx -f | grep -i "error"
```

> Порада: Багато утиліт читають з **stdin**, якщо замість імені файлу вказати `-` (де це підтримується).

---

## 2) Перенаправлення (`>`, `>>`) — запис у файл

- `>` — **перезаписати** файл (створити або очистити).
- `>>` — **додати** в кінець (append), не стираючи наявне.

Приклади:
```bash
history | grep sudo > sudo_commands.txt
history | grep rm   >> sudo_commands.txt  # додати, не перезаписуючи
date > /tmp/run_at.txt                     # простий приклад
```

Корисно зберігати проміжні результати конвеєра для подальшого аналізу.

**Писати у файл і одночасно бачити на екрані — `tee`:**
```bash
journalctl -u nginx | grep -i error | tee "logs_errors.txt"
# додавання замість перезапису:
journalctl -u nginx | grep -i error | tee -a "logs_errors.txt"
```

---

## 3) Стандартні потоки: **stdin / stdout / stderr**

- **stdin (0):** звідки команда читає (типово — клавіатура або попередня команда в конвеєрі).
- **stdout (1):** куди команда пише нормальний вивід (типово — екран).
- **stderr (2):** куди команда пише **помилки** (типово — екран, **не йде** в конвеєр, якщо не перенаправити).

### Приклади керування помилками
```bash
# Лише помилки у файл
ls /root 2> errors.log

# Нормальний вивід у один файл, помилки — в інший
grep -R "TODO" . > out.log 2> err.log

# Об’єднати stderr у stdout (спільний потік → у файл)
mycmd > all.log 2>&1
# коротко в bash: mycmd &> all.log

# Сховати все (і stdout, і stderr)
mycmd > /dev/null 2>&1
```

> Зверніть увагу: `cmd1 | cmd2` передає **stdout** `cmd1`. Якщо `cmd1` друкує помилки у **stderr**, вони **не потраплять** у `cmd2`, поки не виконаєте `2>&1`.

---

## 4) Кілька команд в одному рядку

- `;` — виконати **послідовно**, незалежно від успішності попередньої:
  ```bash
  clear; sleep 1; echo "Команди виконано"
  ```
- `&&` — виконати **наступну лише якщо попередня успішна** (код 0):
  ```bash
  make build && echo "OK"
  ```
- `||` — виконати **наступну, якщо попередня впала** (код ≠ 0):
  ```bash
  make build || echo "Помилка збірки"
  ```

> Порада (просунуто): для скриптів корисно `set -o pipefail` — тоді збій **будь‑якої** команди в конвеєрі призведе до помилки всього конвеєра.

---

## 5) Практикум (15–25 хв)

1. **Пагінація великих логів**
   ```bash
   cat /var/log/syslog | less
   ```
2. **Фільтрація історії**
   ```bash
   history | grep "sudo" | less
   history | grep -i "apt install" > installs.txt
   ```
3. **Підрахунок збігів**
   ```bash
   dmesg | grep -i "usb" | wc -l
   ```
4. **Запис і перегляд одночасно**
   ```bash
   journalctl -u ssh | grep -i "fail" | tee -a ssh_failures.log
   ```
5. **Розділити нормальний вивід і помилки**
   ```bash
   grep -R "TODO" /etc > found.txt 2> errors.txt
   ```
6. **Умова виконання**
   ```bash
   ls /root > /dev/null 2>&1 && echo "Доступ є" || echo "Доступу немає"
   ```

> *Результат:* впевнено будуєте конвеєри, керуєте потоками та пишете результати в файли для аналізу.

---

## 6) Поширені помилки та поради

- **Переплутали `>` і `>>`** → випадковий перезапис. Якщо хвилюєтесь — спершу використовуйте `>>`.
- **Помилки не проходять через `|`** → додайте `2>&1`, якщо потрібно обробляти їх у конвеєрі.
- **Відсутні лапки** навколо пошукової фрази з пробілами → порожній або не той результат.
- **Труби вимагають «стримінгових» інструментів**: деякі команди очікують файли, але багато хто вміє читати `stdin` з `-`.
- **Продуктивність**: складні конвеєри над дуже великими даними можуть навантажувати CPU/диск — додавайте фільтри на ранніх етапах (`grep | grep -v ... | head`).

---

## 7) Контрольні питання

1. Чим відрізняються **stdout** і **stderr**? Як спрямувати помилки в конвеєр?
2. Коли використовувати `>` і коли `>>`?
3. Для чого потрібен `tee` і чим відрізняється `tee -a`?
4. Що робить `;` порівняно з `&&` і `||`?
5. Як порахувати кількість рядків із «error» у журналі сервісу за останній запуск? (приклад ланцюжка команд)

---

## 8) Аналогія: «Фабрика та конвеєр»

- **Конвеєризація (`|`)** — конвеєрна стрічка між машинами: результат **history** іде на обробку **grep**, а потім на сортування/перегляд **less**.
- **Перенаправлення (`>`, `>>`)** — відвід конвеєра на **склад (файл)**: одинарний `>` — перезатерти склад, подвійний `>>` — акуратно **додати**.
- **stdout** — «продукт без браку», **stderr** — «брак».
- **`;`/`&&`/`||`** — набір інструкцій машині: виконати послідовно, лише при успіху або при невдачі.

---

## 9) Шпаргалка операторів

```
|        # конвеєр: stdout лівої → stdin правої
> FILE   # перезаписати файл
>> FILE  # додати в кінець
2> FILE  # помилки (stderr) у файл
2>> FILE # додати помилки в кінець
&> FILE  # stdout і stderr у файл (bash)
2>&1     # злити stderr у stdout
< FILE   # подати файл як stdin
tee F    # показати на екрані і записати у файл
;        # виконати наступну команду завжди
&&       # виконати наступну при успіху
||       # виконати наступну при помилці
```

---

> **Короткий підсумок:** Конвеєри дозволяють будувати **потоки обробки** прямо в терміналі, а перенаправлення — **зберігати чи розводити** потоки виводу. Опануйте `|`, `>`, `>>`, `2>`, `2>&1`, `tee` — і ваші щоденні задачі в Linux стануть у рази швидшими.
