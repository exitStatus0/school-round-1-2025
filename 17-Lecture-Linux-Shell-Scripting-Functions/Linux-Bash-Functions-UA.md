# Лекція: **Функції у Bash — структура, параметри, повернення значень**

> Останній ключовий елемент Bash‑скриптингу — **функції**. Вони структурують код, усувають дублювання (DRY) і підвищують надійність. Розберемо синтаксис, параметри, булеві значення, повернення результатів і практичні патерни.

---

## Навчальні цілі
Після лекції ви зможете:
- Оголошувати та викликати **функції** різними стилями.
- Передавати **параметри** у функції та обробляти їх безпечно.
- Писати **коментарі**, документувати поведінку функцій.
- Працювати з **булевою логікою** (`true`/`false`, коди виходу).
- **Повертати значення**: числові коди (`return`) і дані через `echo/printf`.
- Будувати бібліотеки невеликих, **перевикористовуваних** функцій у скриптах DevOps.

---

## План лекції
1. Навіщо функції: читабельність і DRY
2. Оголошення й виклик: синтаксис і стиль
3. Параметри функцій: `$1`, `$@`, `shift`, значення за замовчуванням
4. Коментарі та самодокументованість
5. Булева логіка в Bash: `true/false`, коди виходу
6. Повернення значень: `return` (0–255) vs `echo/printf`
7. Приклади й патерни DevOps
8. Практикум (20–30 хв)
9. Поширені помилки та поради
10. Контрольні питання
11. Аналогія «Кухар і рецепти»
12. Шпаргалка

---

## 1) Навіщо функції
- **Читабельність**: Розбивають довгі скрипти на зрозумілі блоки з назвами (`setup_user`, `deploy_app`).
- **DRY**: Логіка пишеться один раз і перевикористовується.
- **Тестованість і супровід**: Легше локалізувати помилки й змінювати окремі частини.

---

## 2) Оголошення й виклик

Два рівноцінні стилі оголошення:
```bash
mysay_1() {
  printf 'Hello, %s\n' "${1:-world}"
}

function mysay_2 {
  printf 'Hello, %s\n' "${1:-world}"
}
```

> Рекомендації стилю:
> - Використовуйте **`name()`** (лаконічніше).
> - Всередині функції для тимчасових змінних — **`local`**.
> - Єдиний вихід — `return` або завершення тіла функції.

Виклик функції — просто ім’ям:
```bash
mysay_1 "Bash"    # → Hello, Bash
mysay_2           # → Hello, world
```

---

## 3) Параметри функцій

Всередині функції доступні:
- `$1`, `$2`, … — позиційні параметри
- `$#` — кількість параметрів
- `"$@"` — **список аргументів** (кожен окремо, зберігає пробіли)
- `"$*"` — усі аргументи **одним рядком** (використовується рідше)

Безпечний шаблон обробки:
```bash
create_file() {
  local path="${1:-}"
  local mode="${2:-644}"   # значення за замовчуванням
  [ -n "$path" ] || { echo "path is required" >&2; return 2; }
  : > "$path" || return 3
  chmod "$mode" "$path"
}
```

Опціонально можна «знімати» оброблені параметри:
```bash
myfn() {
  local opt="${1:-default}"; shift || true
  # тепер "$@" — решта параметрів
}
```

> Рекомендація: **<= 5 параметрів** на функцію. Якщо більше — розбийте на менші функції або використайте опції `getopts`.

---

## 4) Коментарі та самодокументованість

Однорядкові коментарі:
```bash
# Створити порожній файл і застосувати права
create_file "/tmp/demo.txt" 600
```

Псевдо «блочні» коментарі (хередок до `:`):
```bash
: <<'DOC'
Цей блок не виконується, зручно для тимчасових заміток
або розгорнутого пояснення алгоритму.
DOC
```

Докстрінг‑шаблон у функції:
```bash
backup_dir() {
  # usage: backup_dir <src_dir> <dest_dir>
  :
}
```

---

## 5) Булева логіка: `true`/`false`, коди виходу

У Bash істинність визначається **кодом виходу**: `0` — **істина/успіх**, `!=0` — **хиба/помилка**.
```bash
is_readable() {
  [[ -r "$1" ]]
}

if is_readable "/etc/hosts"; then
  echo "OK"
else
  echo "NO"
fi
```

Команди `true` і `false` просто повертають 0 або 1:
```bash
true   # успіх
false  # помилка
```

---

## 6) Повернення значень

- `return <num>` — повертає **числовий код** (0–255). Придатно для «так/ні» або класифікації помилок.
- Щоб повернути **дані** (рядок/число будь‑якої величини) — **виведіть** їх (`echo`/`printf`) і зчитайте у виклику через підстановку команд `$(...)`.

Приклад: **код успіху** і **рядкове значення**:
```bash
sum2() {           # повертає «дані» через stdout
  local a="${1:-0}" b="${2:-0}"
  printf '%s' "$((a + b))"
}

add_user_safe() {  # повертає код успіху/помилки
  local name="${1:-}"
  [ -n "$name" ] || return 2
  id -u "$name" >/dev/null 2>&1 && return 0
  sudo adduser --disabled-password --gecos '' "$name"
}

res="$(sum2 3 9)"           # res="12"
if add_user_safe "svcapp"; then
  echo "user ok"
else
  echo "user failed with $?"   # код помилки
fi
```

> Пам’ятайте: `return` обмежений 0–255; значення більших чисел буде обрізано. Для складних результатів — друкуйте JSON/текст і парсіть.

---

## 7) Приклади й патерни DevOps

**Універсальний логер:**
```bash
log() { printf '%s [%s] %s\n' "$(date -Is)" "${1:-INFO}" "${2:-}"; }

log INFO  "Старт деплою"
log WARN  "Конфіг відсутній — використовую значення за замовчуванням"
log ERROR "Збій підключення до БД"
```

**Перевірка залежностей:**
```bash
require_cmd() { command -v "$1" >/dev/null 2>&1 || { echo "need $1" >&2; return 127; }; }
require_cmd tar
require_cmd curl
```

**Очікування доступності порту/сервісу:**
```bash
wait_for_tcp() { # usage: wait_for_tcp <host> <port> [timeout_s]
  local h="$1" p="$2" t="${3:-30}" start end
  start=$(date +%s)
  while ! (echo >"/dev/tcp/$h/$p") >/dev/null 2>&1; do
    sleep 1
    end=$(date +%s)
    (( end - start >= t )) && { echo "timeout $h:$p" >&2; return 1; }
  done
}
```

**Ідемпотентне створення каталогу з правами:**
```bash
ensure_dir() {
  local d="$1" mode="${2:-750}"
  [ -d "$d" ] || sudo mkdir -p -- "$d" || return
  sudo chmod "$mode" -- "$d"
}
```

---

## 8) Практикум (20–30 хв)

1) **Функція `farewell` і `try`**
```bash
farewell() { echo "Error: $*" >&2; exit 1; }
try() { "$@" || farewell "failed: $*"; }
```

2) **Бекап каталогу**
```bash
backup_dir() { # usage: backup_dir <src> <dest_dir>
  local src="$1" dest="$2" base ts
  [ -d "$src" ] || { echo "no src: $src" >&2; return 2; }
  mkdir -p -- "$dest"
  base="$(basename "$src")"; ts="$(date +%F-%H%M%S)"
  tar -czf "$dest/${base}-${ts}.tgz" -C "$(dirname "$src")" "$base"
}
```

3) **Валідація конфігів**
```bash
check_conf() { # usage: check_conf <file>
  local f="$1"
  [[ -s "$f" && -r "$f" ]] || { echo "bad conf: $f" >&2; return 3; }
}
```

4) **Збір метрик**
```bash
mem_free() { awk '/MemFree/ {print $2}' /proc/meminfo; }   # kB
cpu_cores() { nproc; }
echo "free_kb=$(mem_free) cores=$(cpu_cores)"
```

---

## 9) Поширені помилки та поради

- **Не цитуються параметри** у функціях → ламання на пробілах/спецсимволах. Завжди `"$1"`, `"$@"`.
- Плутають **`return` (код)** із поверненням даних → для даних використовуйте `echo/printf`.
- Відсутність `local` → глобальні змінні «протікають» у скрипті.
- Занадто **багато параметрів** → розбийте на менші функції або використовуйте `getopts`.
- Вивалювання помилок у середині пайплайнів: увімкніть `set -euo pipefail` на початку скрипта.
- Зловживання `sudo` в функціях → делегуйте привілеї точково або перевіряйте `EUID`.
- Відсутність **usage‑рядків** та прикладів → важко підтримувати через місяць.

---

## 10) Контрольні питання

1. Чим відрізняються два стилі оголошення функцій у Bash?
2. Як безпечно зчитати параметри функції та задати значення за замовчуванням?
3. У чому різниця між **`return`** і **`echo/printf`** у контексті «повернення значення»?
4. Як перевірити **істинність** функції у виразі `if ...; then`?
5. Навіщо ключове слово **`local`** усередині функцій?
6. Які переваги надають коментарі й usage‑блоки для підтримки скриптів?

---

## 11) Аналогія: «Кухар і рецепти»

- **Функція** — окремий **рецепт** (соус, маринад).
- **Визначення** рецепта — запис на картці; **виклик** — початок готування.
- **Параметри** — інгредієнти рецепта (помідори/базилік).
- **Коментарі** — нотатки на полях («додати сіль за смаком»).
- **Повернення** — готовий компонент (або сигнал «щось пішло не так» кодом).

---

## 12) Шпаргалка

```bash
# Оголошення
myfn() { :; }             # мінімальна функція
function other { :; }      # альтернативний стиль

# Параметри
myfn "arg1" "arg 2"
myfn() { local a="${1:-}"; shift || true; for x in "$@"; do echo "$x"; done; }

# Булева логіка
is_dir() { [[ -d "$1" ]]; }  # повертає 0/1
if is_dir "/tmp"; then echo OK; fi

# Повернення
retcode() { return 5; }      # код → $?
value()   { printf '%s' "data"; }  # дані → stdout
v="$(value)" ; retcode; rc=$?

# Коментарі
# це коментар
: <<'NOTE'
блочний «коментар» через хередок
NOTE
```

---

> **Висновок:** Функції — це фундамент структурованих Bash‑скриптів. Використовуйте короткі, сфокусовані функції з чіткими параметрами, документуйте їх, повертайте коди для контролю потоку й віддавайте дані через stdout — так ваші скрипти стануть чистими, надійними та легкими в підтримці.
